// Copyright 2014 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

import 'package:meta/meta.dart';

import '../../artifacts.dart';
import '../../base/common.dart';
import '../../base/file_system.dart';
import '../../base/io.dart';
import '../../convert.dart';
import '../../devfs.dart';
import '../../globals.dart' as globals;
import '../build_system.dart';
import 'dart.dart';

/// The build define controlling whether icon fonts should be stripped down to
/// only the glyphs used by the application.
const String kFontSubsetFlag = 'FontSubset';

/// Whether icon font subsetting is enabled by default.
const bool kFontSubsetEnabledDefault = false;

List<Map<String, dynamic>> _getList(dynamic object) {
  assert(object is List<dynamic>);
  return (object as List<dynamic>).cast<Map<String, dynamic>>();
}

/// A class that wraps the functionality of the const finder package and the
/// font subset utility to tree shake unused icons from fonts.
class FontSubset {
  /// Creates a wrapper for icon font subsetting.
  ///
  /// The environment parameter must not be null.
  ///
  /// The `fontManifest` parameter must not be null, and must point to the
  /// content of the `FontManifest.json` file generated by the flutter tool.
  ///
  /// The constructor will validate the environment and print a warning if
  /// font subsetting has been requested in a debug build mode.
  FontSubset(this._environment, DevFSStringContent fontManifest) : assert(_environment != null) {
    if (_environment.defines[kFontSubsetFlag] == 'true' &&
        _environment.defines[kBuildMode] == 'debug') {
      globals.printError('Font subetting is not supported in debug mode. The '
                         '--font-subset flag will be ignored.');
    }
    _getIconData(_environment, fontManifest);
  }

  final Environment _environment;

  Map<String, _FontSubsetData> _iconData;

  /// Whether font subsetting should be used for this [Environment].
  bool get enabled => _environment.defines[kFontSubsetFlag] == 'true' && _environment.defines[kBuildMode] != 'debug';

  /// Fills the [_iconData] map.
  Future<void> _getIconData(Environment environment, DevFSStringContent fontManifest) async {
    if (!enabled) {
      return;
    }

    final File appDill = environment.buildDir.childFile('app.dill');

    final File constFinder = globals.fs.file(globals.artifacts.getArtifactPath(Artifact.constFinder));
    final File dart = globals.fs.file(globals.artifacts.getArtifactPath(Artifact.engineDartBinary));

    final Map<String, List<int>> iconData = await _findConstants(dart, constFinder, appDill);
    final Set<String> familyKeys = iconData.keys.toSet();

    final Map<String, String> fonts = await _parseFontJson(fontManifest.string, familyKeys);

    if (fonts.length != iconData.length) {
      throwToolExit('Expected to find fonts for ${iconData.keys}, but found ${fonts.keys}.');
    }

    final Map<String, _FontSubsetData> result = <String, _FontSubsetData>{};
    for (final MapEntry<String, String> entry in fonts.entries) {
      result[entry.value] = _FontSubsetData(
        family: entry.key,
        relativePath: entry.value,
        codePoints: iconData[entry.key],
      );
    }
    return result;
  }


  /// Calls font-subset, which transforms the `inputPath` font file to a
  /// subsetted version at `outputPath`.
  ///
  /// The `relativePath` parameter
  ///
  /// All parameters are required.
  ///
  /// If [enabled] is false, or the relative path is not recognized as an icon
  /// font used in the Flutter application, this returns false.
  /// If the font-subset subprocess fails, it will [throwToolExit].
  /// Otherwise, it will return true.
  Future<bool> subsetFont({
    @required Environment environment,
    @required String inputPath,
    @required String outputPath,
    @required String relativePath,
  }) async {
    if (!enabled) {
      return false;
    }

    final _FontSubsetData fontSubsetData = _iconData[relativePath];
    if (fontSubsetData == null) {
      return false;
    }

    final File fontSubset = globals.fs.file(globals.artifacts.getArtifactPath(Artifact.fontSubset));

    final List<String> cmd = <String>[
      fontSubset.path,
      outputPath,
      inputPath,
    ];
    final String codePoints = fontSubsetData.codePoints.join(' ');
    globals.printTrace('Running font-subset: ${cmd.join(' ')}, using codepoints $codePoints');
    final Process fontSubsetProcess = await globals.processManager.start(cmd);
    try {
      fontSubsetProcess.stdin.writeln(codePoints);
      await fontSubsetProcess.stdin.flush();
      await fontSubsetProcess.stdin.close();
    } catch (e) {
      // handled by checking the exit code.
    }

    final int code = await fontSubsetProcess.exitCode;
    if (code != 0) {
      globals.printTrace(await utf8.decodeStream(fontSubsetProcess.stdout));
      globals.printError(await utf8.decodeStream(fontSubsetProcess.stderr));
      throwToolExit('Font subsetting failed with exit code $code.');
    }
    return true;
  }

  /// Returns a map of { fontFamly: relativePath } pairs.
  Future<Map<String, String>> _parseFontJson(String fontManifestData, Set<String> families) async {
    final Map<String, String> result = <String, String>{};
    final List<Map<String, dynamic>> fontList = _getList(json.decode(fontManifestData));
    for (final Map<String, dynamic> map in fontList) {
      final String familyKey = map['family'] as String;
      if (families.contains(familyKey)) {
        final List<Map<String, dynamic>> fonts = _getList(map['fonts']);
        if (fonts.length != 1) {
          throwToolExit('This tool cannot process icon fonts with multiple fonts in a single family.');
        }
        result[familyKey] = fonts.first['asset'] as String;
      }
    }
    return result;
  }

  Future<Map<String, List<int>>> _findConstants(File dart, File constFinder, File appDill) async {
    final List<String> cmd = <String>[
      dart.path,
      constFinder.path,
      '--kernel-file', appDill.path,
      '--class-library-uri', 'package:flutter/src/widgets/icon_data.dart',
      '--class-name', 'IconData',
    ];
    globals.printTrace('Running command: ${cmd.join(' ')}');
    final ProcessResult constFinderProcessResult = await globals.processManager.run(cmd);

    if (constFinderProcessResult.exitCode != 0) {
      throwToolExit('ConstFinder failure: ${constFinderProcessResult.stderr}');
    }
    final Map<String, dynamic> constFinderMap = json.decode(constFinderProcessResult.stdout as String) as Map<String, dynamic>;
    final _ConstFinderResult constFinderResult = _ConstFinderResult(constFinderMap);
    if (constFinderResult.hasNonConstantLocations) {
      globals.printError('This application cannot tree shake icons fonts. It has non-constant instances of IconData at the following locations:', emphasis: true);
      for (final Map<String, dynamic> location in constFinderResult.nonConstantLocations) {
        globals.printError('- ${location['file']}:${location['line']}:${location['column']}', indent: 2, hangingIndent: 4);
      }
      throwToolExit('Avoid non-constant invocations of IconData or try to build again without --shake-icon-fonts.');
    }
    return _parseConstFinderResult(constFinderResult);
  }

  Map<String, List<int>> _parseConstFinderResult(_ConstFinderResult consts) {
    final Map<String, List<int>> result = <String, List<int>>{};
    for (final Map<String, dynamic> iconDataMap in consts.constantInstances) {
      final String package = iconDataMap['fontPackage'] as String;
      final String family = iconDataMap['fontFamily'] as String;
      final String key = package == null
        ? family
        : 'packages/$package/$family';
      result[key] ??= <int>[];
      result[key].add(iconDataMap['codePoint'] as int);
    }
    return result;
  }

}

class _ConstFinderResult {
  const _ConstFinderResult(this.result);

  final Map<String, dynamic> result;
  List<Map<String, dynamic>> get constantInstances => _getList(result['constantInstances']);
  List<Map<String, dynamic>> get nonConstantLocations => _getList(result['nonConstantLocations']);

  bool get hasNonConstantLocations => nonConstantLocations.isNotEmpty;
}

/// The font family name, relative path to font file, and list of code points
/// the application is using.
class _FontSubsetData {
  /// All parameters are required.
  const _FontSubsetData({
    @required this.family,
    @required this.relativePath,
    @required this.codePoints,
  }) : assert(family != null),
       assert(relativePath != null),
       assert(codePoints != null);

  /// The font family name, e.g. "MaterialIcons".
  final String family;

  /// The relative path to the font file.
  final String relativePath;

  /// The list of code points for the font.
  final List<int> codePoints;

  @override
  String toString() => 'FontSubsetData($family, $relativePath, $codePoints)';
}
