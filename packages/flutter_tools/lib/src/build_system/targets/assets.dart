// Copyright 2019 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

import 'package:meta/meta.dart';
import 'package:pool/pool.dart';

import '../../asset.dart';
import '../../base/file_system.dart';
import '../../devfs.dart';
import '../../plugins.dart';
import '../../project.dart';
import '../build_system.dart';
import '../groups.dart';

class AssetsBuildPhase extends TargetGroup {
  const AssetsBuildPhase({@required this.outputPrefix});

  final String outputPrefix;

  @override
  Future<List<Target>> plan(Environment environment) async {
    final List<Source> inputs = <Source>[
      const Source.pattern('{FLUTTER_ROOT}/packages/flutter_tools/lib/src/build_system/targets/assets.dart'),
      const Source.pattern('{PROJECT_DIR}/pubspec.yaml'),
    ];
    final List<Source> outputs = <Source>[
      Source.pattern('$outputPrefix/AssetManifest.json'),
      Source.pattern('$outputPrefix/FontManifest.json'),
      Source.pattern('$outputPrefix/LICENSE'),
    ];
    final AssetBundle assetBundle = AssetBundleFactory.instance.createBundle();
    await assetBundle.build(
      manifestPath: environment.projectDir.childFile('pubspec.yaml').path,
      packagesPath: environment.projectDir.childFile('.packages').path,
    );
    // Filter the file type to remove the files that are generated by this
    // command as inputs.
    final Iterable<DevFSFileContent> files = assetBundle.entries.values.whereType<DevFSFileContent>();
    for (DevFSFileContent devFsContent in files) {
      final String path = devFsContent.file.path;
      inputs.add(Source.pattern(path));
    }
    for (String key in assetBundle.entries.keys) {
      outputs.add(Source.pattern('$outputPrefix/$key'));
    }

    return <Target>[
      CopyAssets(
        inputs: inputs,
        outputs: outputs,
      ),
    ];
  }

  @override
  List<String> get dependencies => <String>[];

  @override
  String get name => 'assets';
}

/// Copy the assets defined in the flutter manifest into a build directory.
class CopyAssets extends Target {
  const CopyAssets({
    this.inputs,
    this.outputs,
    this.outputPrefix,
  });

  @override
  String get name => 'copy_assets';

  @override
  List<Target> get dependencies => const <Target>[];

  @override
  final List<Source> inputs;

  @override
  final List<Source> outputs;

  @override
  Future<void> build(List<File> inputFiles, Environment environment) async {
    final Directory output = environment
      .buildDir
      .childDirectory('flutter_assets');
    if (output.existsSync()) {
      output.deleteSync(recursive: true);
    }
    output.createSync(recursive: true);
    final AssetBundle assetBundle = AssetBundleFactory.instance.createBundle();
    await assetBundle.build(
      manifestPath: environment.projectDir.childFile('pubspec.yaml').path,
      packagesPath: environment.projectDir.childFile('.packages').path,
    );
    // Limit number of open files to avoid running out of file descriptors.
    final Pool pool = Pool(64);
    await Future.wait<void>(
      assetBundle.entries.entries.map<Future<void>>((MapEntry<String, DevFSContent> entry) async {
        final PoolResource resource = await pool.request();
        try {
          final File file = fs.file(fs.path.join(output.path, entry.key));
          file.parent.createSync(recursive: true);
          await file.writeAsBytes(await entry.value.contentsAsBytes());
        } finally {
          resource.release();
        }
      }));
  }
}

/// Rewrites the `.flutter-plugins` file of [project] based on the plugin
/// dependencies declared in `pubspec.yaml`.
// TODO(jonahwiliams): this should be per platform and located in build
// outputs.
class FlutterPlugins extends Target {
  const FlutterPlugins();

  @override
  String get name => 'flutter_plugins';

  @override
  List<Target> get dependencies => const <Target>[];

  @override
  List<Source> get inputs => const <Source>[
    Source.pattern('{FLUTTER_ROOT}/packages/flutter_tools/lib/src/build_system/targets/assets.dart'),
    Source.pattern('{PROJECT_DIR}/pubspec.yaml'),
  ];

  @override
  List<Source> get outputs => const <Source>[
    Source.pattern('{PROJECT_DIR}/.flutter-plugins')
  ];

  @override
  Future<void> build(List<File> inputFiles, Environment environment) async {
    // The pubspec may change for reasons other than plugins changing, so we compare
    // the manifest before writing. Some hosting build systems use timestamps
    // so we need to be careful to avoid tricking them into doing more work than
    // necessary.
    final FlutterProject project = FlutterProject.fromDirectory(environment.projectDir);
    final List<Plugin> plugins = findPlugins(project);
    final String pluginManifest = plugins
        .map<String>((Plugin p) => '${p.name}=${escapePath(p.path)}')
        .join('\n');
    final File flutterPluginsFile = environment.projectDir.childFile('.flutter-plugins');
    if (!flutterPluginsFile.existsSync() || flutterPluginsFile.readAsStringSync() != pluginManifest) {
      flutterPluginsFile.writeAsStringSync(pluginManifest);
    }
  }
}
