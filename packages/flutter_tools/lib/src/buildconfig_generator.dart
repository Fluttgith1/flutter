// Copyright 2018 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

import 'dart:async';

import 'package:args/args.dart';
import 'package:meta/meta.dart';

import 'base/common.dart';
import 'base/file_system.dart';
import 'base/logger.dart';
import 'base/utils.dart';
import 'build_info.dart';
import 'bundle.dart' as bundle;
import 'flutter_manifest.dart';
import 'globals.dart';

const String _kFileName = 'build_config.g.dart';

Future<Null> generateBuildConfigClass({@required BuildInfo buildInfo, ArgResults args}) async {
  return generateBuildConfigClassAtPath(buildInfo: buildInfo, args: args);
}

@visibleForTesting
Future<Null> generateBuildConfigClassAtPath({@required BuildInfo buildInfo, ArgResults args, String projectPath}) async {
  assert(buildInfo != null, 'buildInfo can\'t be null');

  final Status status = logger.startProgress('Generating \'$_kFileName\' file...', expectSlowOperation: true);
  final String outputPath = (projectPath == null)
      ? fs.path.join('lib', _kFileName)
      : fs.path.join(projectPath, 'lib', _kFileName);

  File buildConfig;
  IOSink sink;

  try {
    buildConfig = fs.file(outputPath);
    if (buildConfig.existsSync()) {
      buildConfig.deleteSync();
    }
    buildConfig.createSync();

    final String content = await _generateContent(buildInfo: buildInfo, projectPath: projectPath, args: args);

    sink = buildConfig.openWrite();
    sink.write(content);
    status.stop();
  } catch (error) {
    printStatus('Failed to generate $_kFileName file');
    printError('$error');
    status.stop();
    throwToolExit('Failed to load pubspec.yaml: $error');
  } finally {
    await sink?.flush();
    await sink?.close();
  }
}

Future<String> _generateContent({@required BuildInfo buildInfo, String projectPath, ArgResults args}) async {
  assert(buildInfo != null, 'buildInfo can\'t be null');

  final String flutterManifest = (projectPath == null)
      ? fs.path.join(bundle.defaultManifestPath)
      : fs.path.join(projectPath, bundle.defaultManifestPath);

  FlutterManifest manifest;
  try {
    manifest = await FlutterManifest.createFromPath(flutterManifest);
  } catch (error) {
    throwToolExit('Failed to load pubspec.yaml: $error');
  }

  final DateTime now = clock.now();
  final StringBuffer output = new StringBuffer();
  output.writeln('// GENERATED CODE - DO NOT MODIFY BY HAND');
  output.writeln('// Will be (re-)generated by flutter run or flutter build command.\n');
  output.writeln('class BuildConfig {');
  output.writeln('  static const String kBuildTime = \'${now.toIso8601String()}\';');
  output.writeln('  static const int kBuildTimeMillisecondsSinceEpoch = ${now.millisecondsSinceEpoch};');
  output.writeln('  static const bool kDebug = ${buildInfo.isDebug};');
  output.writeln('  static const String kModeName = \'${buildInfo.modeName}\';');
  output.writeln('  static const String kFlavor = ${buildInfo.flavor == null ? null : _escape(buildInfo.flavor)};');

  final String buildName = buildInfo?.buildName ?? manifest.buildName;
  output.writeln('  static const String kVersionName = ${buildName == null ? null : _escape(buildName)};');

  final int buildNumber = buildInfo?.buildNumber ?? manifest.buildNumber;
  output.writeln('  static const int kVersionNumber = ${buildNumber == null ? null : buildNumber};');

  if (args != null && args.options.isNotEmpty) {
    output.writeln('  static const Map<String, dynamic> kBuildArguments = {');
    output.writeln('    ${args.options.map((String option) => '\'$option\': ${_escape(args[option])}').join(',\n    ')}');
    output.writeln('  };');
  }
  output.writeln('}');

  return output.toString();
}

dynamic _escape(dynamic value) {
  if (value is String) {
    return '\'$value\'';
  } else {
    return value;
  }
}
