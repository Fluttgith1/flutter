// Copyright 2014 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

import 'package:flutter/foundation.dart';
import 'package:flutter/services.dart';
import 'package:flutter/src/services/keyboard_keys.dart';

/// An interface that allows querying the state of a keyboard.
///
/// [KeyboardState] is typically used by [KeyboardStateCriterion.state], to test
/// whether the keyboard is at a state that meets certain conditions.
///
/// [KeyboardState] objects are actually [HardwareKeyboard] objects (typically
/// the global singleton). The [KeyboardState] interface is used to discourage
/// side effects during criterion testing.
abstract class KeyboardState {
  /// Returns true if the keyboard has the given physical key pressed.
  bool physicalPressed(PhysicalKeyboardKey key);

  /// Returns true if the keyboard has the given logical key pressed.
  bool logicalPressed(LogicalKeyboardKey key);

  /// Returns true if the keyboard has the given lock mode enabled.
  bool modeEnabled(KeyboardLockMode lockMode);
}

/// Defines the interface for keyboard key events.
///
/// The event provides an abstraction for the [physicalKey] and [logicalKey],
/// describing the physical location of the key, and the logical meaning of the
/// key, respectively. For [KeyDownEvent]s, the character produced by the event
/// (if any) is also included.
///
/// See also:
///
///  * [LogicalKeyboardKey], an object that describes the logical meaning of a
///    key.
///  * [KeyboardKey], an object that describes the physical location of
///    a key.
///  * [KeyDownEvent], a subclass for events representing the user
///    pressing a key.
///  * [KeyUpEvent], a subclass for events representing the user
///    releasing a key.
///  * [KeySyncEvent], a subclass for events representing the user
///    pressing a key when Flutter doesn't have focus.
///  * [KeyCancelEvent], a subclass for events representing the user
///    releasing a key when Flutter doesn't have focus.
///  * [HardwareKeyboard], which can be listened to for key events.
///  * [HardwareKeyboardListener], a widget that listens for hardware key events.
@immutable
abstract class KeyEvent with Diagnosticable {
  /// Create a KeyEvent by providing each field.
  const KeyEvent({
    required this.physical,
    required this.logical,
    this.character,
    required this.timeStamp,
    this.synthesized = false,
  });

  /// Returns an object representing the physical location of this key.
  ///
  /// {@template flutter.services.KeyEvent.physicalKeyboardKey}
  /// A [PhysicalKeyboardKey] represents a USB HID code sent from the keyboard,
  /// ignoring the key map, modifier keys (like SHIFT), and the label on the key.
  ///
  /// [PhysicalKeyboardKey]s are used to describe and test for keys in a
  /// particular location. A [PhysicalKeyboardKey] may have a name, but the name
  /// is a mnemonic ("keyA" is easier to remember than 0x70004), derived from the
  /// key's effect on a QWERTY keyboard. The name does not represent the key's
  /// effect whatsoever (a physical "keyA" can be the Q key on an AZERTY
  /// keyboard.)
  ///
  /// For instance, if you wanted to make a game where the key to the right of
  /// the CAPS LOCK key made the player move left, you would be comparing a
  /// physical key with [PhysicalKeyboardKey.keyA], since that is the key next to
  /// the CAPS LOCK key on a QWERTY keyboard. This would return the same thing
  /// even on an AZERTY keyboard where the key next to the CAPS LOCK produces a
  /// "Q" when pressed.
  /// {@endtemplate}
  ///
  /// If you want to make your app respond to a key with a particular character
  /// on it regardless of location of the key, use [KeyEvent.logicalKey] instead.
  ///
  /// See also:
  ///
  ///  * [logicalKey] for the non-location specific key generated by this event.
  ///  * [character] for the character generated by this keypress (if any).
  final PhysicalKeyboardKey physical;

  /// Returns an object representing the logical key that was pressed.
  ///
  /// {@template flutter.services.KeyEvent.logicalKey}
  /// This method takes into account the key map and modifier keys (like SHIFT)
  /// to determine which logical key to return.
  ///
  /// If you are looking for the character produced by a key event, use
  /// [KeyEvent.character] instead.
  ///
  /// If you are collecting text strings, use the [TextField] or
  /// [CupertinoTextField] widgets, since those automatically handle many of the
  /// complexities of managing keyboard input, like showing a soft keyboard or
  /// interacting with an input method editor (IME).
  /// {@endtemplate}
  final LogicalKeyboardKey logical;

  /// Returns the Unicode character (grapheme cluster) completed by this
  /// keystroke, if any.
  ///
  /// This will only return a character if this keystroke, combined with any
  /// preceding keystroke(s), generated a character, and only on a "key down"
  /// event. It will return null if no character has been generated by the
  /// keystroke (e.g. a "dead" or "combining" key), or if the corresponding key
  /// is a key without a visual representation, such as a modifier key or a
  /// control key.
  ///
  /// This can return multiple Unicode code points, since some characters (more
  /// accurately referred to as grapheme clusters) are made up of more than one
  /// code point.
  ///
  /// The [character] doesn't take into account edits by an input method editor
  /// (IME), or manage the visibility of the soft keyboard on touch devices. For
  /// composing text, use the [TextField] or [CupertinoTextField] widgets, since
  /// those automatically handle many of the complexities of managing keyboard
  /// input.
  ///
  /// The [character] is not available on [KeyUpEvent]s.
  final String? character;

  /// Time of event, relative to an arbitrary start point.
  ///
  /// All events share the same timeStamp origin.
  final Duration timeStamp;

  /// Whether this event is synthesized by Flutter to synchronize key states.
  ///
  /// An non-[synthesized] event is converted from a native event, and a native
  /// event can only be converted to one non-[synthesized] event. Some properties
  /// might be changed during the conversion (for example, a native repeat event
  /// might be converted to a Flutter down event when necessary.)
  ///
  /// A [synthesized] event is created without a source native event in order to
  /// synthronize key states. For example, if the native platform shows that a
  /// Shift key that was previously held has been released somehow without the
  /// key up event dispatched (probably due to loss of focus), a synthesized key
  /// up event will be synthesized.
  final bool synthesized;

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties.add(DiagnosticsProperty<PhysicalKeyboardKey>('physical', physical));
    properties.add(DiagnosticsProperty<LogicalKeyboardKey>('logical', logical));
    properties.add(StringProperty('character', character));
    properties.add(DiagnosticsProperty<Duration>('timeStamp', timeStamp));
    properties.add(FlagProperty('synthesized', value: synthesized, ifTrue: 'synthesized'));
  }
}

/// An interface to define whether the keyboard is at a desired state.
///
/// This is usually used to check whether a key is pressed (or not pressed) at
/// the moment, or the combination of such conditions from multiple keys.
///
/// Subclasses should implement this class and overwride [active].
abstract class KeyboardStateCriterion {
  const KeyboardStateCriterion._();

  /// Returns true when the keyboard is at a `state` that fully satisfies the
  /// conditions intended by this class.
  bool active(KeyboardState state);
}

/// An interface to define whether the keyboard event meets desired conditions.
///
/// This is usually used to check whether the event is triggered by a certain
/// key (physical or logical), inputs certain character, or the combination of
/// such conditions.
///
/// Subclasses should implement this class and overwride [fulfilled].
abstract class KeyboardEventCriterion {
  /// A const constructor so that subclasses may be const.
  const KeyboardEventCriterion._();

  /// Returns true when all the keyboard event fully satisfies the conditions
  /// intended by this class.
  bool fulfilled(KeyEvent event);
}

/// A base class for all keyboard key types.
///
/// See also:
///
///  * [PhysicalKeyboardKey], a class with static values that describe the keys
///    that are returned from [RawKeyEvent.physicalKey].
///  * [LogicalKeyboardKey], a class with static values that describe the keys
///    that are returned from [RawKeyEvent.logicalKey].
abstract class KeyboardKey with Diagnosticable
    implements KeyboardStateCriterion, KeyboardEventCriterion {
  /// A const constructor so that subclasses may be const.
  const KeyboardKey();
}

class NegateStateCriterion implements KeyboardStateCriterion {
  const NegateStateCriterion(this.base, { this.negate = true });

  final KeyboardStateCriterion base;

  final bool negate;

  @override
  bool active(KeyboardState state) => base.active(state) ^ negate;
}