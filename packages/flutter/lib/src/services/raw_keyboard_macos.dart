// Copyright 2019 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

import 'package:flutter/foundation.dart';

import 'keyboard_key.dart';
import 'keyboard_maps.dart';
import 'raw_keyboard.dart';

class RawKetEventDataMacOs extends RawKeyEventData {
  /// Creates a key event data structure specific for macOS.
  ///
  /// The [flags], [codePoint], [keyCode], [scanCode], and [metaState] arguments
  /// must not be null.
  const RawKetEventDataMacOs(
      {this.characters = '',
      this.charactersIgnoringModifiers = '',
      this.keyCode = 0,
      this.modifiers = 0})
      : assert(characters != null),
        assert(charactersIgnoringModifiers != null),
        assert(keyCode != null),
        assert(modifiers != null);

  /// Documentation extracted from Apple's NSEvent doc:
  /// https://developer.apple.com/documentation/appkit/nsevent?language=objc

  /// The characters associated with a key-up or key-down event.
  ///
  /// These characters are derived from a keyboard mapping that associates
  /// various key combinations with Unicode characters. This property is only
  /// valid for key-up and key-down events. It raises an
  /// NSInternalInconsistencyException if accessed on any other kind of event object.
  ///
  /// This property is set to an empty string for dead keys, such as Option-e.
  /// However, for a key combination such as Option-Shift-e this property is set
  /// to the standard accent ("´").
  final String characters;

  /// The characters generated by a key event as if no modifier key (except for
  /// Shift) applies.
  ///
  /// This property is set to the non-modifier key character pressed for dead
  /// keys, such as Option-e. For example, Option-e (no shift key) returns an
  /// “e" for this method, whereas the characters property returns an empty string.
  ///
  ///This property is useful for determining “basic” key values in a
  /// hardware-independent manner, enabling such features as keyboard equivalents
  /// defined in terms of modifier keys plus character keys. For example, to
  /// determine if the user typed Alt-S, you don’t have to know whether Alt-S
  /// generates a German double ess, an integral sign, or a section symbol. You
  /// simply examine the string contained by this property along with the event’s
  /// modifier flags, checking for “s” and NSAlternateKeyMask.
  final String charactersIgnoringModifiers;

  /// The virtual key code for the keyboard key associated with a key event.
  ///
  /// The property’s value is hardware-independent. The value returned is the
  /// same as the value returned in the kEventParamKeyCode when using Carbon
  /// Events.
  final int keyCode;

  /// A mask of the current modifiers using the values in Modifier Flags.

  /// This returns the state of devices combined with synthesized events at
  /// the moment, independent of which events have been delivered via the
  /// event stream.
  final int modifiers;

  @override
  String get keyLabel =>
      charactersIgnoringModifiers.isEmpty ? null : charactersIgnoringModifiers;

  @override
  PhysicalKeyboardKey get physicalKey =>
      kMacOsToPhysicalKey[keyCode] ?? PhysicalKeyboardKey.none;

  @override
  LogicalKeyboardKey get logicalKey {
    // Look to see if the keyCode is a printable number pad key, so that a
    // difference between regular keys (e.g. "=") and the number pad version
    // (e.g. the "=" on the number pad) can be determined.
    final LogicalKeyboardKey numPadKey = kMacOsNumPadMap[keyCode];
    if (numPadKey != null) {
      return numPadKey;
    }

    // Look to see if the keyCode is one we know about and have a mapping for.
    LogicalKeyboardKey newKey = _keyCodeFromUnmodifiedCharacter();
    if (newKey != null) {
      return newKey;
    }

    // This is a non-printable key that we don't know about, so we mint a new
    // code with the autogenerated bit set.
    const int macOsKeyIdPlane = 0x00500000000;
    newKey ??= LogicalKeyboardKey(
      macOsKeyIdPlane | keyCode | LogicalKeyboardKey.autogeneratedMask,
      debugName: kReleaseMode ? null : 'Unknown macOS key code $keyCode',
    );
    return newKey;
  }

  /// Get the LogicalKeyboardKey from the generated character. Since macOS uses
  /// keyCode for both their logical and physical keys, we rely on the
  /// generated character to map to a LogicalKeyboardKey. If it's not found in
  /// this map, defauts to the kMacOsToLogicalKey map.
  /// Map taken from https://cs.chromium.org/chromium/src/ui/events/keycodes/keyboard_code_conversion_mac.mm?l=781&rcl=e2827ff648bb1363e59da927746eb80b9a287e5f
  LogicalKeyboardKey _keyCodeFromUnmodifiedCharacter() {
    if (charactersIgnoringModifiers.isEmpty) {
      return kMacOsToLogicalKey[keyCode];
    }
    switch (charactersIgnoringModifiers.substring(0, 1)) {
      case 'a':
      case 'A':
        return LogicalKeyboardKey.keyA;
      case 'b':
      case 'B':
        return LogicalKeyboardKey.keyB;
      case 'c':
      case 'C':
        return LogicalKeyboardKey.keyC;
      case 'd':
      case 'D':
        return LogicalKeyboardKey.keyD;
      case 'e':
      case 'E':
        return LogicalKeyboardKey.keyE;
      case 'f':
      case 'F':
        return LogicalKeyboardKey.keyF;
      case 'g':
      case 'G':
        return LogicalKeyboardKey.keyG;
      case 'h':
      case 'H':
        return LogicalKeyboardKey.keyH;
      case 'i':
      case 'I':
        return LogicalKeyboardKey.keyI;
      case 'j':
      case 'J':
        return LogicalKeyboardKey.keyJ;
      case 'k':
      case 'K':
        return LogicalKeyboardKey.keyK;
      case 'l':
      case 'L':
        return LogicalKeyboardKey.keyL;
      case 'm':
      case 'M':
        return LogicalKeyboardKey.keyM;
      case 'n':
      case 'N':
        return LogicalKeyboardKey.keyN;
      case 'o':
      case 'O':
        return LogicalKeyboardKey.keyO;
      case 'p':
      case 'P':
        return LogicalKeyboardKey.keyP;
      case 'q':
      case 'Q':
        return LogicalKeyboardKey.keyQ;
      case 'r':
      case 'R':
        return LogicalKeyboardKey.keyR;
      case 's':
      case 'S':
        return LogicalKeyboardKey.keyS;
      case 't':
      case 'T':
        return LogicalKeyboardKey.keyT;
      case 'u':
      case 'U':
        return LogicalKeyboardKey.keyU;
      case 'v':
      case 'V':
        return LogicalKeyboardKey.keyV;
      case 'w':
      case 'W':
        return LogicalKeyboardKey.keyW;
      case 'x':
      case 'X':
        return LogicalKeyboardKey.keyX;
      case 'y':
      case 'Y':
        return LogicalKeyboardKey.keyY;
      case 'z':
      case 'Z':
        return LogicalKeyboardKey.keyZ;

      // U.S. Specific mappings.  Mileage may vary.
      case ';':
      case ':':
        return LogicalKeyboardKey.semicolon;
      case '=':
      case '+':
        return LogicalKeyboardKey.equal;
      case ',':
      case '<':
        return LogicalKeyboardKey.comma;
      case '-':
      case '_':
        return LogicalKeyboardKey.minus;
      case '.':
      case '>':
        return LogicalKeyboardKey.period;
      case '/':
      case '?':
        return LogicalKeyboardKey.slash;
      case '`':
      case '~':
        return LogicalKeyboardKey.backquote;
      case '[':
      case '{':
        return LogicalKeyboardKey.bracketLeft;
      case '\\':
      case '|':
        return LogicalKeyboardKey.backslash;
      case ']':
      case '}':
        return LogicalKeyboardKey.bracketRight;
      case '\'':
      case '"':
        return LogicalKeyboardKey.quote;
    }

    return kMacOsToLogicalKey[keyCode];
  }

  @override
  bool isModifierPressed(ModifierKey key,
      {KeyboardSide side = KeyboardSide.any}) {
    final int independentModifier = modifiers & deviceIndependentMask;
    switch (key) {
      case ModifierKey.controlModifier:
        return independentModifier & modifierControl != 0;
      case ModifierKey.shiftModifier:
        return independentModifier & modifierShift != 0;
      case ModifierKey.altModifier:
        return independentModifier & modifierOption != 0;
      case ModifierKey.metaModifier:
        return independentModifier & modifierCommand != 0;
      case ModifierKey.capsLockModifier:
        return independentModifier & modifierCapsLock != 0;
      case ModifierKey.numLockModifier:
        return independentModifier & modifierNumericPad != 0;
      case ModifierKey.functionModifier:
      case ModifierKey.symbolModifier:
      case ModifierKey.scrollLockModifier:
        // These are not included in macOS.
        return false;
    }
    return false;
  }

  @override
  KeyboardSide getModifierSide(ModifierKey key) => KeyboardSide.any;

  // Modifier key masks.

  /// This mask is used to check the [modifiers] field to test whether the CAPS
  /// LOCK modifier key is on.
  ///
  /// Use this value if you need to decode the [modifiers] field yourself, but
  /// it's much easier to use [isModifierPressed] if you just want to know if
  /// a modifier is pressed.
  static const int modifierCapsLock = 1 << 16;

  /// This mask is used to check the [modifiers] field to test whether one of the
  /// SHIFT modifier keys is pressed.
  ///
  /// Use this value if you need to decode the [modifiers] field yourself, but
  /// it's much easier to use [isModifierPressed] if you just want to know if
  /// a modifier is pressed.
  static const int modifierShift = 1 << 17;

  /// This mask is used to check the [modifiers] field to test whether one of the
  /// CTRL modifier keys is pressed.
  ///
  /// Use this value if you need to decode the [modifiers] field yourself, but
  /// it's much easier to use [isModifierPressed] if you just want to know if
  /// a modifier is pressed.
  static const int modifierControl = 1 << 18;

  /// This mask is used to check the [modifiers] field to test whether one of the
  /// ALT modifier keys is pressed.
  ///
  /// Use this value if you need to decode the [modifiers] field yourself, but
  /// it's much easier to use [isModifierPressed] if you just want to know if
  /// a modifier is pressed.
  static const int modifierOption = 1 << 19;

  /// This mask is used to check the [modifiers] field to test whether one of the
  /// CMD modifier keys is pressed.
  ///
  /// Use this value if you need to decode the [modifiers] field yourself, but
  /// it's much easier to use [isModifierPressed] if you just want to know if
  /// a modifier is pressed.
  static const int modifierCommand = 1 << 20;

  /// This mask is used to check the [modifiers] field to test whether any key in
  /// the numeric keypad is pressed.
  ///
  /// Use this value if you need to decode the [modifiers] field yourself, but
  /// it's much easier to use [isModifierPressed] if you just want to know if
  /// a modifier is pressed.
  static const int modifierNumericPad = 1 << 21;

  /// This mask is used to check the [modifiers] field to test whether the
  /// HELP modifier key is pressed.
  ///
  /// Use this value if you need to decode the [modifiers] field yourself, but
  /// it's much easier to use [isModifierPressed] if you just want to know if
  /// a modifier is pressed.
  static const int modifierHelp = 1 << 22;

  /// This mask is used to check the [modifiers] field to test whether one of the
  /// FUNCTION modifier keys is pressed.
  ///
  /// Use this value if you need to decode the [modifiers] field yourself, but
  /// it's much easier to use [isModifierPressed] if you just want to know if
  /// a modifier is pressed.
  static const int modifierFunction = 1 << 23;

  // Used to retrieve only the device-independent modifier flags, allowing applications to mask off the device-dependent modifier flags, including event coalescing information.
  static const int deviceIndependentMask = 0xffff0000;

  @override
  String toString() {
    return '$runtimeType(keyLabel: $keyLabel keyCode: $keyCode, characters: $characters,'
        ' unmodifiedCharacters: $charactersIgnoringModifiers, modifiers: $modifiers, '
        'modifiers down: $modifiersPressed)';
  }
}
