// Copyright 2014 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

import 'dart:collection' show LinkedList, LinkedListEntry;

import 'package:flutter/foundation.dart';
import 'binding.dart';
import 'keyboard_key.dart';

/// Defines the interface for keyboard key events.
///
/// The event provides an abstraction for the [physicalKey] and [logicalKey],
/// describing the physical location of the key, and the logical meaning of the
/// key, respectively. For [KeyDownEvent]s, the character produced by the event
/// (if any) is also included.
///
/// See also:
///
///  * [LogicalKeyboardKey], an object that describes the logical meaning of a
///    key.
///  * [KeyboardKey], an object that describes the physical location of
///    a key.
///  * [KeyDownEvent], a subclass for events representing the user
///    pressing a key.
///  * [KeyUpEvent], a subclass for events representing the user
///    releasing a key.
///  * [KeySyncEvent], a subclass for events representing the user
///    pressing a key when Flutter doesn't have focus.
///  * [KeyCancelEvent], a subclass for events representing the user
///    releasing a key when Flutter doesn't have focus.
///  * [HardwareKeyboard], which can be listened to for key events.
///  * [HardwareKeyboardListener], a widget that listens for hardware key events.
@immutable
abstract class KeyEvent with Diagnosticable {
  /// Create a KeyEvent by providing each field.
  const KeyEvent({
    required this.physical,
    required this.logical,
    this.character,
    required this.timeStamp,
    this.synthesized = false,
  });

  /// Returns an object representing the physical location of this key.
  ///
  /// {@template flutter.services.KeyEvent.physicalKeyboardKey}
  /// A [PhysicalKeyboardKey] represents a USB HID code sent from the keyboard,
  /// ignoring the key map, modifier keys (like SHIFT), and the label on the key.
  ///
  /// [PhysicalKeyboardKey]s are used to describe and test for keys in a
  /// particular location. A [PhysicalKeyboardKey] may have a name, but the name
  /// is a mnemonic ("keyA" is easier to remember than 0x70004), derived from the
  /// key's effect on a QWERTY keyboard. The name does not represent the key's
  /// effect whatsoever (a physical "keyA" can be the Q key on an AZERTY
  /// keyboard.)
  ///
  /// For instance, if you wanted to make a game where the key to the right of
  /// the CAPS LOCK key made the player move left, you would be comparing a
  /// physical key with [PhysicalKeyboardKey.keyA], since that is the key next to
  /// the CAPS LOCK key on a QWERTY keyboard. This would return the same thing
  /// even on an AZERTY keyboard where the key next to the CAPS LOCK produces a
  /// "Q" when pressed.
  /// {@endtemplate}
  ///
  /// If you want to make your app respond to a key with a particular character
  /// on it regardless of location of the key, use [KeyEvent.logicalKey] instead.
  ///
  /// See also:
  ///
  ///  * [logicalKey] for the non-location specific key generated by this event.
  ///  * [character] for the character generated by this keypress (if any).
  final PhysicalKeyboardKey physical;

  /// Returns an object representing the logical key that was pressed.
  ///
  /// {@template flutter.services.KeyEvent.logicalKey}
  /// This method takes into account the key map and modifier keys (like SHIFT)
  /// to determine which logical key to return.
  ///
  /// If you are looking for the character produced by a key event, use
  /// [KeyEvent.character] instead.
  ///
  /// If you are collecting text strings, use the [TextField] or
  /// [CupertinoTextField] widgets, since those automatically handle many of the
  /// complexities of managing keyboard input, like showing a soft keyboard or
  /// interacting with an input method editor (IME).
  /// {@endtemplate}
  final LogicalKeyboardKey logical;

  final String? character;

  /// Time of event, relative to an arbitrary start point.
  ///
  /// All events share the same timeStamp origin.
  final Duration timeStamp;

  /// Whether this event is synthesized by Flutter to synchronize key states.
  ///
  /// An non-[synthesized] event is converted from a native event, and a native
  /// event can only be converted to one non-[synthesized] event. Some properties
  /// might be changed during the conversion (for example, a native repeat event
  /// might be converted to a Flutter down event when necessary.)
  ///
  /// A [synthesized] event is created without a source native event in order to
  /// synthronize key states. For example, if the native platform shows that a
  /// Shift key that was previously held has been released somehow without the
  /// key up event dispatched (probably due to loss of focus), a synthesized key
  /// up event will be synthesized.
  final bool synthesized;

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties.add(DiagnosticsProperty<PhysicalKeyboardKey>('physical', physical));
    properties.add(DiagnosticsProperty<LogicalKeyboardKey>('logical', logical));
    properties.add(StringProperty('character', character));
    properties.add(DiagnosticsProperty<Duration>('timeStamp', timeStamp));
    properties.add(FlagProperty('synthesized', value: synthesized, ifTrue: 'synthesized'));
  }
}

/// An event indicating that the user has pressed a key down on the keyboard.
///
/// See also:
///
///  * [HardwareKeyboard], which produces this event.
class KeyDownEvent extends KeyEvent {
  /// Creates a key event that represents the user pressing a key.
  const KeyDownEvent({
    required PhysicalKeyboardKey physical,
    required LogicalKeyboardKey logical,
    String? character,
    required Duration timeStamp,
    bool synthesized = false,
  }) : super(
         physical: physical,
         logical: logical,
         character: character,
         timeStamp: timeStamp,
         synthesized: synthesized,
       );
}

/// An event indicating that the user has released a key on the keyboard.
///
/// See also:
///
///  * [HardwareKeyboard], which produces this event.
class KeyUpEvent extends KeyEvent {
  /// Creates a key event that represents the user pressing a key.
  const KeyUpEvent({
    required PhysicalKeyboardKey physical,
    required LogicalKeyboardKey logical,
    required Duration timeStamp,
    bool synthesized = false,
  }) : super(
         physical: physical,
         logical: logical,
         timeStamp: timeStamp,
         synthesized: synthesized,
       );
}

/// An event indicating that the user has been holding a key on the keyboard
/// and causing repeated events.
///
/// See also:
///
///  * [HardwareKeyboard], which produces this event.
class KeyRepeatEvent extends KeyEvent {
  /// Creates a key event that represents the user pressing a key.
  const KeyRepeatEvent({
    required PhysicalKeyboardKey physical,
    required LogicalKeyboardKey logical,
    String? character,
    required Duration timeStamp,
  }) : super(
         physical: physical,
         logical: logical,
         character: character,
         timeStamp: timeStamp,
       );
}

class _ListenerEntry<T> extends LinkedListEntry<_ListenerEntry<T>> {
  _ListenerEntry(this.listener);
  final ValueChanged<T> listener;
}

abstract class _ValueDispatcher<T> {
  LinkedList<_ListenerEntry<T>>? _listeners = LinkedList<_ListenerEntry<T>>();

  bool _debugAssertNotDisposed() {
    assert(() {
      if (_listeners == null) {
        throw FlutterError(
          'A $runtimeType was used after being disposed.\n'
          'Once you have called dispose() on a $runtimeType, it can no longer be used.'
        );
      }
      return true;
    }());
    return true;
  }

  /// Register a closure to be called when the object notifies its listeners.
  void addListener(ValueChanged<T> listener) {
    assert(_debugAssertNotDisposed());
    _listeners!.add(_ListenerEntry<T>(listener));
  }

  /// Remove a previously registered closure from the list of closures that the
  /// object notifies.
  void removeListener(ValueChanged<T> listener) {
    assert(_debugAssertNotDisposed());
    for (final _ListenerEntry<T> entry in _listeners!) {
      if (entry.listener == listener) {
        entry.unlink();
        return;
      }
    }
  }

  @mustCallSuper
  void dispose() {
    assert(_debugAssertNotDisposed());
    _listeners = null;
  }

  /// Call all the registered listeners.
  ///
  /// Call this method whenever the object changes, to notify any clients the
  /// object may have changed. Listeners that are added during this iteration
  /// will not be visited. Listeners that are removed during this iteration will
  /// not be visited after they are removed.
  ///
  /// Exceptions thrown by listeners will be caught and reported using
  /// [FlutterError.reportError].
  ///
  /// This method must not be called after [dispose] has been called.
  ///
  /// Surprising behavior can result when reentrantly removing a listener (i.e.
  /// in response to a notification) that has been registered multiple times.
  /// See the discussion at [removeListener].
  @protected
  @visibleForTesting
  void notifyListeners(T value) {
    assert(_debugAssertNotDisposed());
    if (_listeners!.isEmpty)
      return;

    final List<_ListenerEntry<T>> localListeners = List<_ListenerEntry<T>>.from(_listeners!);

    for (final _ListenerEntry<T> entry in localListeners) {
      try {
        if (entry.list != null)
          entry.listener(value);
      } catch (exception, stack) {
        FlutterError.reportError(FlutterErrorDetails(
          exception: exception,
          stack: stack,
          library: 'services library',
          context: ErrorDescription('while dispatching notifications for $runtimeType'),
          informationCollector: () sync* {
            yield DiagnosticsProperty<_ValueDispatcher<T>>(
              'The $runtimeType sending notification was',
              this,
              style: DiagnosticsTreeStyle.errorProperty,
            );
          },
        ));
      }
    }
  }
}

/// An interface to listen to hardware [KeyEvent]s and query key states.
/// 
/// [HardwareKeyboard] dispatches key events from hardware keyboards (in contrast
/// to on-screen keyboards) received from the native platform after
/// normalization. To stay notified whenever keys are pressed and released, add a
/// listener with [addListener]. Alternatively, you can listen to key events only
/// when specific part of the app is focused with [Focus.onKeyEvent].
/// 
/// [HardwareKeyboard] also offers basic state querying. Query whether a key is
/// being held, or a lock key is enabled, with [physicalKeyPressed],
/// [logicalKeyPressed], or [locked].
/// 
/// The singleton [HardwareKeyboard] instance is held by the [ServicesBinding] as
/// [ServicesBinding.hardwareKeyboard], and can be conveniently accessed using the
/// [HardwareKeyboard.instance] static accessor.
/// 
/// ## Event model
///
/// Flutter normalizes hardware key events from the native platform in terms of
/// event model and key options, while preserving platform-specific features as
/// much as possible.
/// 
/// [HardwareKeyboard] tries to dispatch events following the model as follows:
/// 
///  * At initialization, all keys are released.
///  * A key press sequence always consists of one [KeyDownEvent], zero or more 
///    [KeyRepeatEvent]s, and one [KeyUpEvent].
///  * All events in the same key press sequence have the same physical key and
///    logical key.
///  * Only [KeyDownEvent]s and [KeyRepeatEvent]s may have `character`, which
///    might vary within the key press sequence.
///  * Lock state always toggles at a respetive [KeyDownEvent].
/// 
/// However, this model might not be met on some platforms until the migration
/// period is over, since the [KeyEvent]s on these platforms are still one-to-one
/// mapped from [RawKeyEvent]s.
/// 
/// The resulting events might not map one-to-one to native key events. A
/// [KeyEvent] that does not correspond to a native event is marked as
/// `synthesized`.
/// 
/// ## Compared to [RawKeyboard]
/// 
/// [RawKeyboard] is the legacy API, will be deprecated and removed in the
/// future.
/// 
/// [RawKeyboard] dispatches events that contain raw key event data and computes
/// unified key information in the framework. [RawKeyboard] provides a less
/// unified, less regular event model than [HardwareKeyboard], and includes
/// unnecessary mapping data of other platforms in the app.
/// 
/// It is recommended to always use [HardwareKeyboard] and [KeyEvent] APIs to
/// handle key events.
///
/// See also:
///
///  * [KeyDownEvent] and [KeyUpEvent], the classes used to describe specific key
///    events.
///  * [RawKeyboard], the legacy API that dispatches key events containing raw
///    system data.
///  * [ServiceBinding.hardwareKeyboard], a typical global singleton of this class.
abstract class HardwareKeyboard extends _ValueDispatcher<KeyEvent> {

  /// Provides convenient access to the current [HardwareKeyboard] singleton from
  /// the [ServicesBinding] instance.
  static HardwareKeyboard get instance => ServicesBinding.instance!.hardwareKeyboard;

  /// Whether [HardwareKeyboard] is using data from [ui.KeyData], or
  /// [RawKeyEvent] otherwise.
  ///
  /// While [HardwareKeyboard] is designed for the new API [ui.KeyData], it is
  /// compatible with the legacy API [RawKeyEvent] during the deprecation
  /// process. The flag [receivingKeyData] is recorded to disable events from
  /// [RawKeyEvent] on platforms where [ui.KeyData] is available, and to disable
  /// certain sanity assertions for the legacy API.
  @protected
  bool receivingKeyData = false;

  /// Register a listener that is called every time the user presses or releases
  /// a hardware keyboard key.
  ///
  /// If the callback returns true, the event is considered handled by Flutter
  /// and will not be propagated to other native components. If the callback
  /// returns false, the native event (possibly a clone of the original one) will
  /// be propagated to other native components.
  ///
  /// Most applications prefer to use the focus system (see [Focus] and
  /// [FocusManager]) to receive key events to the focused control instead of
  /// this kind of passive listener.
  ///
  /// Listeners can be removed with [removeListener].
  @override
  void addListener(ValueChanged<KeyEvent> listener) { super.addListener(listener); }

  /// Stop calling the given listener every time the user presses or releases a
  /// hardware keyboard key.
  ///
  /// Listeners can be added with [addListener].
  @override
  void removeListener(ValueChanged<KeyEvent> listener) { super.removeListener(listener); }

  final Map<int, int> _physicalPressCount = <int, int>{};
  /// Returns true if the given [PhysicalKeyboardKey] is pressed.
  /// 
  /// If used during a key event listener, the result will have taken the event
  /// into account.
  /// 
  /// If multiple key down events with the same physical `usbHidUsage` have been
  /// observed, the result will turn false only with the same number of key up
  /// events.
  ///
  /// See also:
  /// 
  ///  * [physicalKeyPressed], which tells if a physical key is being pressed.
  ///  * [locked], which tells if a logical lock key is enabled.
  bool physicalKeyPressed(PhysicalKeyboardKey physical) {
    final int? count = _physicalPressCount[physical.usbHidUsage];
    assert(count == null || count > 0);
    return count != null && count > 0;
  }

  final Map<int, int> _logicalPressCount = <int, int>{};
  /// Returns true if the given [LogicalKeyboardKey] is pressed.
  /// 
  /// If used during a key event listener, the result will have taken the event
  /// into account.
  /// 
  /// If multiple key down events with the same logical `keyId` have been
  /// observed, the result will turn false only with the same number of key up
  /// events.
  ///
  /// See also:
  /// 
  ///  * [physicalKeyPressed], which tells if a physical key is being pressed.
  ///  * [locked], which tells if a logical lock key is enabled.
  bool logicalKeyPressed(LogicalKeyboardKey logical) {
    final int? count = _logicalPressCount[logical.keyId];
    assert(count == null || count > 0);
    return count != null && count > 0;
  }

  late final Map<int, bool> _locked = Map<int, bool>.fromEntries(
    lockKeys.map((int logicalKey) => MapEntry<int, bool>(logicalKey, true)),
  );
  /// Returns true if the lock flag of the given [LogicalKeyboardKey] is enabled.
  /// 
  /// Lock keys, such as CapsLock, are logical keys that toggle their
  /// respective boolean states on key down events. Such flags are usually used
  /// as modifier to other keys or events.
  /// 
  /// If used during a key event listener, the result will have taken the event
  /// into account.
  bool locked(LogicalKeyboardKey logical) {
    assert(lockKeys.contains(logical.keyId));
    return _locked.update(logical.keyId, (bool isOn) => !isOn);
  }

  /// Updates states with `event`, and sends the `event` to listeners.
  ///
  /// This method is called by subclasses, typically
  /// [ServiceBinding.hardwareKeyboard], which is responsible to accept raw data
  /// (such as [ui.KeyData]) and convert them to [KeyEvent].
  @protected
  void dispatchKeyEvent(KeyEvent event) {
    if (event is KeyDownEvent) {
      _physicalPressCount.update(event.physical.usbHidUsage,
        (int count) => count + 1,
        ifAbsent: () => 1,
      );
      _logicalPressCount.update(event.logical.keyId,
        (int count) => count + 1,
        ifAbsent: () => 1,
      );
    } else if (event is KeyUpEvent) {
      int Function() alertMissingKey(Object info) {
        return () {
          // Only throw assertion for KeyData. RawKeyEvent does not guarantee this.
          assert(!receivingKeyData,
              'KeyUpEvent refers to key ${info.toString()}, which has not been pressed.');
          return 0;
        };
      }
      final int physicalCount = _physicalPressCount.update(event.physical.usbHidUsage,
        (int count) => count - 1, ifAbsent: alertMissingKey(event.physical));
      if (physicalCount == 0) {
        _physicalPressCount.remove(event.physical.usbHidUsage);
      }
      final int logicalCount = _logicalPressCount.update(event.logical.keyId,
        (int count) => count - 1, ifAbsent: alertMissingKey(event.logical));
      if (logicalCount == 0) {
        _logicalPressCount.remove(event.logical.keyId);
      }
    } else if (event is KeyRepeatEvent) {
      assert(!receivingKeyData || _physicalPressCount.containsKey(event.physical.usbHidUsage));
      assert(!receivingKeyData || _logicalPressCount.containsKey(event.logical.keyId));
    }
    notifyListeners(event);
  }

  /// A collection of logical keys that are considered lock keys.
  ///
  /// Each lock key has a [locked] status that is toggled with every key down
  /// event.
  ///
  /// Some platforms might not support all lock keys included in [lockKeys].
  static final Set<int> lockKeys = <int>{
    LogicalKeyboardKey.numLock.keyId,
    LogicalKeyboardKey.scrollLock.keyId,
    LogicalKeyboardKey.capsLock.keyId,
  };
}
