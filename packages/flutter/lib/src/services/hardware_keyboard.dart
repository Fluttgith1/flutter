// Copyright 2014 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

import 'dart:collection' show LinkedList, LinkedListEntry;
import 'dart:async';
import 'dart:typed_data';
import 'dart:ui' as ui;

import 'package:flutter/foundation.dart';
import './keyboard_key.dart';

/// Defines the interface for keyboard key events.
///
/// The event provides an abstraction for the [physicalKey] and [logicalKey],
/// describing the physical location of the key, and the logical meaning of the
/// key, respectively. For [KeyDownEvent]s, the character produced by the event
/// (if any) is also included.
///
/// See also:
///
///  * [LogicalKeyboardKey], an object that describes the logical meaning of a
///    key.
///  * [PhysicalKeyboardKey], an object that describes the physical location of
///    a key.
///  * [KeyDownEvent], a subclass for events representing the user
///    pressing a key.
///  * [KeyUpEvent], a subclass for events representing the user
///    releasing a key.
///  * [KeySyncEvent], a subclass for events representing the user
///    pressing a key when Flutter doesn't have focus.
///  * [KeyCancelEvent], a subclass for events representing the user
///    releasing a key when Flutter doesn't have focus.
///  * [HardwareKeyboard], which can be listened to for key events.
///  * [HardwareKeyboardListener], a widget that listens for hardware key events.
@immutable
abstract class PhysicalKeyEvent with Diagnosticable {
  const PhysicalKeyEvent({required this.physicalKey, required this.timeStamp});

  /// Returns an object representing the physical location of this key.
  ///
  /// {@template flutter.services.KeyEvent.physicalKey}
  /// The [PhysicalKeyboardKey] ignores the key map, modifier keys (like SHIFT),
  /// and the label on the key. It describes the location of the key as if it
  /// were on a QWERTY keyboard regardless of the keyboard mapping in effect.
  ///
  /// [PhysicalKeyboardKey]s are used to describe and test for keys in a
  /// particular location.
  ///
  /// For instance, if you wanted to make a game where the key to the right of
  /// the CAPS LOCK key made the player move left, you would be comparing the
  /// result of this `physicalKey` with [PhysicalKeyboardKey.keyA], since that
  /// is the key next to the CAPS LOCK key on a QWERTY keyboard. This would
  /// return the same thing even on a French keyboard where the key next to the
  /// CAPS LOCK produces a "Q" when pressed.
  ///
  /// If you want to make your app respond to a key with a particular character
  /// on it regardless of location of the key, use [KeyEvent.logicalKey] instead.
  /// {@endtemplate}
  ///
  /// See also:
  ///
  ///  * [logicalKey] for the non-location specific key generated by this event.
  ///  * [character] for the character generated by this keypress (if any).
  final PhysicalKeyboardKey physicalKey;

  /// Time of event, relative to an arbitrary start point.
  ///
  /// All events share the same timeStamp origin.
  final Duration timeStamp;

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties.add(DiagnosticsProperty<PhysicalKeyboardKey>('physicalKey', physicalKey));
    properties.add(DiagnosticsProperty<Duration>('timeStamp', timeStamp));
  }
}

/// An event indicating that the user has pressed a key down on the keyboard.
///
/// See also:
///
///  * [HardwareKeyboard], which produces this event.
class PhysicalKeyDownEvent extends PhysicalKeyEvent {
  /// Creates a key event that represents the user pressing a key.
  const PhysicalKeyDownEvent({
    required Duration timeStamp,
    required PhysicalKeyboardKey physicalKey,
    this.repeated = false,
  }) : super(physicalKey: physicalKey, timeStamp: timeStamp);

  final bool repeated;

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties.add(DiagnosticsProperty<bool>('repeated', repeated, defaultValue: false));
  }
}

/// An event indicating that the user has released a key on the keyboard.
///
/// See also:
///
///  * [HardwareKeyboard], which produces this event.
class PhysicalKeyUpEvent extends PhysicalKeyEvent {
  /// Creates a key event that represents the user releasing a key.
  const PhysicalKeyUpEvent({
    required Duration timeStamp,
    required PhysicalKeyboardKey physicalKey,
  }) : super(physicalKey: physicalKey, timeStamp: timeStamp);
}

/// The user has released a key on the keyboard after Flutter lost input focus.
///
/// This is effectively a key up event, but is generated because the application
/// lost focus before the key was released, and so the key up event was
/// delivered to another application, or dropped by the operating system.
///
/// The application is expected to update state related to this key event, but
/// not to trigger user actions as a result of the event.
///
/// See also:
///
///  * [HardwareKeyboard], which produces this event.
class PhysicalKeyCancelEvent extends PhysicalKeyEvent {
  /// Creates a key event that represents the user releasing a key outside of
  /// the current focus.
  const PhysicalKeyCancelEvent({
    required Duration timeStamp,
    required PhysicalKeyboardKey physicalKey,
  }) : super(physicalKey: physicalKey, timeStamp: timeStamp);
}

/// The user has pressed a key on the keyboard before the current application
/// gained focus.
///
/// This is effectively a key down event, but is generated because the application
/// gained focus after the key was pressed, and so the key down was delivered to
/// another application.
///
/// The application is expected to update state related to this key event, but
/// not to trigger user actions as a result of the event.
///
/// See also:
///
///  * [HardwareKeyboard], which produces this event.
class PhysicalKeySyncEvent extends PhysicalKeyEvent {
  /// Creates a key event that represents the user releasing a key outside of
  /// the current focus.
  const PhysicalKeySyncEvent({
    required Duration timeStamp,
    required PhysicalKeyboardKey physicalKey,
  }) : super(physicalKey: physicalKey, timeStamp: timeStamp);
}

@immutable
abstract class LogicalKeyEvent with Diagnosticable {
  const LogicalKeyEvent({required this.logicalKey, required this.physicalEvent});

  /// Returns an object representing the logical key that was pressed.
  ///
  /// {@template flutter.services.KeyEvent.logicalKey}
  /// This method takes into account the key map and modifier keys (like SHIFT)
  /// to determine which logical key to return.
  ///
  /// If you are looking for the character produced by a key event, use
  /// [KeyEvent.character] instead.
  ///
  /// If you are collecting text strings, use the [TextField] or
  /// [CupertinoTextField] widgets, since those automatically handle many of the
  /// complexities of managing keyboard input, like showing a soft keyboard or
  /// interacting with an input method editor (IME).
  /// {@endtemplate}
  final LogicalKeyboardKey logicalKey;

  final PhysicalKeyEvent physicalEvent;

  /// Time of event, relative to an arbitrary start point.
  ///
  /// All events share the same timeStamp origin.
  Duration get timeStamp => physicalEvent.timeStamp;

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties.add(DiagnosticsProperty<LogicalKeyboardKey>('logicalKey', logicalKey));
    properties.add(DiagnosticsProperty<Duration>('timeStamp', timeStamp));
    properties.add(DiagnosticsProperty<PhysicalKeyEvent>('physicalEvent', physicalEvent, level: DiagnosticLevel.debug));
  }
}

class LogicalKeyDownEvent extends LogicalKeyEvent {
  /// Creates a key event that represents the user pressing a key.
  const LogicalKeyDownEvent({
    required LogicalKeyboardKey logicalKey,
    required PhysicalKeyEvent physicalEvent,
    this.repeated = false,
    this.character,
  }) : super(logicalKey: logicalKey, physicalEvent: physicalEvent);

  final bool repeated;

  /// Returns the Unicode character (grapheme cluster) completed by this
  /// keystroke, if any.
  ///
  /// This will only return a character if this keystroke, combined with any
  /// preceding keystroke(s), generated a character. It will return null if no
  /// character has been generated by the keystroke (e.g. a "dead" or
  /// "combining" key), or if the corresponding key is a key without a visual
  /// representation, such as a modifier key or a control key.
  ///
  /// This can return multiple Unicode code points, since some characters (more
  /// accurately referred to as grapheme clusters) are made up of more than one
  /// code point.
  ///
  /// The `character` doesn't take into account edits by an input method editor
  /// (IME). For composing text, use the [TextField] or [CupertinoTextField]
  /// widgets, since those automatically handle many of the complexities of
  /// managing keyboard input.
  ///
  /// Returns null if there is no character for this event.
  final String? character;

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties.add(StringProperty('character', character, defaultValue: null));
    properties.add(DiagnosticsProperty<bool>('repeated', repeated, defaultValue: false));
  }
}

class LogicalKeyUpEvent extends LogicalKeyEvent {
  /// Creates a key event that represents the user releasing a key.
  const LogicalKeyUpEvent({
    required LogicalKeyboardKey logicalKey,
    required PhysicalKeyEvent physicalEvent,
  }) : super(logicalKey: logicalKey, physicalEvent: physicalEvent);
}

class LogicalKeySyncEvent extends LogicalKeyEvent {
  /// Creates a key event that represents the user pressing a key.
  const LogicalKeySyncEvent({
    required LogicalKeyboardKey logicalKey,
    required PhysicalKeyEvent physicalEvent,
    this.character,
  }) : super(logicalKey: logicalKey, physicalEvent: physicalEvent);

  /// Returns the Unicode character (grapheme cluster) completed by this
  /// keystroke, if any.
  ///
  /// This will only return a character if this keystroke, combined with any
  /// preceding keystroke(s), generated a character. It will return null if no
  /// character has been generated by the keystroke (e.g. a "dead" or
  /// "combining" key), or if the corresponding key is a key without a visual
  /// representation, such as a modifier key or a control key.
  ///
  /// This can return multiple Unicode code points, since some characters (more
  /// accurately referred to as grapheme clusters) are made up of more than one
  /// code point.
  ///
  /// The `character` doesn't take into account edits by an input method editor
  /// (IME). For composing text, use the [TextField] or [CupertinoTextField]
  /// widgets, since those automatically handle many of the complexities of
  /// managing keyboard input.
  ///
  /// Returns null if there is no character for this event.
  final String? character;

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties.add(StringProperty('character', character, defaultValue: null));
  }
}

class LogicalKeyCancelEvent extends LogicalKeyEvent {
  /// Creates a key event that represents the user pressing a key.
  const LogicalKeyCancelEvent({
    required LogicalKeyboardKey logicalKey,
    required PhysicalKeyEvent physicalEvent,
  }) : super(logicalKey: logicalKey, physicalEvent: physicalEvent);
}

class _ListenerEntry<T> extends LinkedListEntry<_ListenerEntry<T>> {
  _ListenerEntry(this.listener);
  final ValueChanged<T> listener;
}

abstract class _ValueDispatcher<T> {
  LinkedList<_ListenerEntry<T>>? _listeners = LinkedList<_ListenerEntry<T>>();

  bool _debugAssertNotDisposed() {
    assert(() {
      if (_listeners == null) {
        throw FlutterError(
          'A $runtimeType was used after being disposed.\n'
          'Once you have called dispose() on a $runtimeType, it can no longer be used.'
        );
      }
      return true;
    }());
    return true;
  }

  /// Register a closure to be called when the object notifies its listeners.
  void addListener(ValueChanged<T> listener) {
    assert(_debugAssertNotDisposed());
    _listeners!.add(_ListenerEntry<T>(listener));
  }

  /// Remove a previously registered closure from the list of closures that the
  /// object notifies.
  void removeListener(ValueChanged<T> listener) {
    assert(_debugAssertNotDisposed());
    for (final _ListenerEntry<T> entry in _listeners!) {
      if (entry.listener == listener) {
        entry.unlink();
        return;
      }
    }
  }

  @mustCallSuper
  void dispose() {
    assert(_debugAssertNotDisposed());
    _listeners = null;
  }

  /// Call all the registered listeners.
  ///
  /// Call this method whenever the object changes, to notify any clients the
  /// object may have changed. Listeners that are added during this iteration
  /// will not be visited. Listeners that are removed during this iteration will
  /// not be visited after they are removed.
  ///
  /// Exceptions thrown by listeners will be caught and reported using
  /// [FlutterError.reportError].
  ///
  /// This method must not be called after [dispose] has been called.
  ///
  /// Surprising behavior can result when reentrantly removing a listener (i.e.
  /// in response to a notification) that has been registered multiple times.
  /// See the discussion at [removeListener].
  @protected
  @visibleForTesting
  void notifyListeners(T value) {
    assert(_debugAssertNotDisposed());
    if (_listeners!.isEmpty)
      return;

    final List<_ListenerEntry<T>> localListeners = List<_ListenerEntry<T>>.from(_listeners!);

    for (final _ListenerEntry<T> entry in localListeners) {
      try {
        if (entry.list != null)
          entry.listener(value);
      } catch (exception, stack) {
        FlutterError.reportError(FlutterErrorDetails(
          exception: exception,
          stack: stack,
          library: 'services library',
          context: ErrorDescription('while dispatching notifications for $runtimeType'),
          informationCollector: () sync* {
            yield DiagnosticsProperty<_ValueDispatcher<T>>(
              'The $runtimeType sending notification was',
              this,
              style: DiagnosticsTreeStyle.errorProperty,
            );
          },
        ));
      }
    }
  }
}

class PhysicalKeyboard extends _ValueDispatcher<PhysicalKeyEvent> {
  PhysicalKeyboard();
}

class LogicalKeyboard extends _ValueDispatcher<LogicalKeyEvent> {
  LogicalKeyboard();
}

class HardwareKeyboard {
  HardwareKeyboard();

  final PhysicalKeyboard physical = PhysicalKeyboard();

  final LogicalKeyboard logical = LogicalKeyboard();

  PhysicalKeyEvent _physicalEventFromData(ui.KeyData keyData) {
    final PhysicalKeyboardKey physicalKey = PhysicalKeyboardKey.findKeyByCode(keyData.key)
        ?? PhysicalKeyboardKey(keyData.key);
    final Duration timeStamp = keyData.timeStamp;
    switch (keyData.change) {
      case ui.KeyChange.down:
        return PhysicalKeyDownEvent(
          physicalKey: physicalKey,
          timeStamp: timeStamp,
        );
      case ui.KeyChange.repeatedDown:
        return PhysicalKeyDownEvent(
          physicalKey: physicalKey,
          timeStamp: timeStamp,
          repeated: true,
        );
      case ui.KeyChange.up:
        return PhysicalKeyUpEvent(
          physicalKey: physicalKey,
          timeStamp: timeStamp,
        );
      case ui.KeyChange.synchronize:
        return PhysicalKeySyncEvent(
          physicalKey: physicalKey,
          timeStamp: timeStamp,
        );
      case ui.KeyChange.cancel:
        return PhysicalKeyCancelEvent(
          physicalKey: physicalKey,
          timeStamp: timeStamp,
        );
    }
  }

  LogicalKeyEvent _logicalEventFromData(ui.LogicalKeyData keyData, PhysicalKeyEvent physicalEvent) {
    final LogicalKeyboardKey logicalKey = LogicalKeyboardKey.findKeyByKeyId(keyData.key)
        ?? LogicalKeyboardKey(keyData.key);
    switch (keyData.change) {
      case ui.KeyChange.down:
        return LogicalKeyDownEvent(
          logicalKey: logicalKey,
          physicalEvent: physicalEvent,
          character: keyData.character,
        );
      case ui.KeyChange.repeatedDown:
        return LogicalKeyDownEvent(
          logicalKey: logicalKey,
          physicalEvent: physicalEvent,
          character: keyData.character,
          repeated: true,
        );
      case ui.KeyChange.up:
        return LogicalKeyUpEvent(
          logicalKey: logicalKey,
          physicalEvent: physicalEvent,
        );
      case ui.KeyChange.synchronize:
        return LogicalKeySyncEvent(
          logicalKey: logicalKey,
          physicalEvent: physicalEvent,
          character: keyData.character,
        );
      case ui.KeyChange.cancel:
        return LogicalKeyCancelEvent(
          logicalKey: logicalKey,
          physicalEvent: physicalEvent,
        );
    }
  }

  void handleKeyData(ui.KeyData keyData) {
    final PhysicalKeyEvent physicalEvent = _physicalEventFromData(keyData);
    _dispatchPhysicalKeyEvent(physicalEvent);
    for(final ui.LogicalKeyData logicalData in keyData.logicalEvents) {
      _dispatchLogicalKeyEvent(_logicalEventFromData(logicalData, physicalEvent));
    }
  }

  void _dispatchPhysicalKeyEvent(PhysicalKeyEvent event) {
    physical.notifyListeners(event);
  }

  void _dispatchLogicalKeyEvent(LogicalKeyEvent event) {
    logical.notifyListeners(event);
  }
}
